/*
 * LudoFile - Kaitai Format Registry Implementation
 *
 * Copyright (c) 2024 LudoPlex
 * SPDX-License-Identifier: Apache-2.0
 */

#define _POSIX_C_SOURCE 200809L

#include "formats.h"
#include <string.h>
#include <stdio.h>

/* ============================================================================
 * Pre-compiled format bytecode
 *
 * NOTE: These are placeholders. In a full implementation, these would be
 * generated by compiling KSY files from kaitai_struct_formats repository.
 * ============================================================================ */

/* GIF format - simplified placeholder */
static const uint8_t gif_bytecode[] = {
    OP_NOP  /* Placeholder */
};

static const VMTypeDef gif_types[] = {
    {
        .name = "gif",
        .fields = NULL,
        .num_fields = 0,
        .flags = 0,
        .bytecode = gif_bytecode,
        .bytecode_len = sizeof(gif_bytecode)
    }
};

/* PNG format - placeholder */
static const uint8_t png_bytecode[] = {
    OP_NOP  /* Placeholder */
};

static const VMTypeDef png_types[] = {
    {
        .name = "png",
        .fields = NULL,
        .num_fields = 0,
        .flags = 0,
        .bytecode = png_bytecode,
        .bytecode_len = sizeof(png_bytecode)
    }
};

/* JPEG format - placeholder */
static const uint8_t jpeg_bytecode[] = {
    OP_NOP  /* Placeholder */
};

static const VMTypeDef jpeg_types[] = {
    {
        .name = "jpeg",
        .fields = NULL,
        .num_fields = 0,
        .flags = 0,
        .bytecode = jpeg_bytecode,
        .bytecode_len = sizeof(jpeg_bytecode)
    }
};

/* ============================================================================
 * Format registry
 * ============================================================================ */

const KaitaiFormatDef KAITAI_FORMATS[] = {
    {
        .mime_type = "image/gif",
        .ksy_name = "gif",
        .bytecode = gif_bytecode,
        .bytecode_len = sizeof(gif_bytecode),
        .types = gif_types,
        .num_types = sizeof(gif_types) / sizeof(gif_types[0])
    },
    {
        .mime_type = "image/png",
        .ksy_name = "png",
        .bytecode = png_bytecode,
        .bytecode_len = sizeof(png_bytecode),
        .types = png_types,
        .num_types = sizeof(png_types) / sizeof(png_types[0])
    },
    {
        .mime_type = "image/jpeg",
        .ksy_name = "jpeg",
        .bytecode = jpeg_bytecode,
        .bytecode_len = sizeof(jpeg_bytecode),
        .types = jpeg_types,
        .num_types = sizeof(jpeg_types) / sizeof(jpeg_types[0])
    }
};

const size_t KAITAI_FORMATS_COUNT = sizeof(KAITAI_FORMATS) / sizeof(KAITAI_FORMATS[0]);

/* ============================================================================
 * API implementation
 * ============================================================================ */

const KaitaiFormatDef *kaitai_find_format(const char *mime_type) {
    if (!mime_type) {
        return NULL;
    }
    
    for (size_t i = 0; i < KAITAI_FORMATS_COUNT; i++) {
        if (strcmp(KAITAI_FORMATS[i].mime_type, mime_type) == 0) {
            return &KAITAI_FORMATS[i];
        }
    }
    
    return NULL;
}

int kaitai_load_format(VM *vm, const KaitaiFormatDef *format) {
    if (!vm || !format) {
        return -1;
    }
    
    /* Register types */
    for (size_t i = 0; i < format->num_types; i++) {
        if (vm_register_type(vm, &format->types[i]) < 0) {
            return -1;
        }
    }
    
    /* Load bytecode */
    if (format->bytecode && format->bytecode_len > 0) {
        vm_set_bytecode(vm, format->bytecode, format->bytecode_len);
    }
    
    return 0;
}

int kaitai_load_by_mime(VM *vm, const char *mime_type) {
    const KaitaiFormatDef *format = kaitai_find_format(mime_type);
    if (!format) {
        return -1;
    }
    
    return kaitai_load_format(vm, format);
}
